#' Benchmark "True" analysis of data simulated by \code{simjm} function
#'
#' \code{simjm_benchmark} fits Cox proportional hazards and semi-parametric additive hazards models
#' to data generated by \code{\link[survtd]{simjm}} using the perfect data, i.e. the true values of the time-dependent markers.
#'
#' @export
#' @param data A data.frame produced by \code{\link[survtd]{simjm}}.
#' @param surv_model Time-to-event model that was used to generate \code{data}. Options are "Cox" for Cox proportional
#' hazard model and "Add" for semi-parametric additive hazards model.
#' @param marker_model Multiple marker model that was used to generate \code{data}. Options are "RE" for the correlated random effects model and "PN" for the
#' product normal model.
#' @param corr Degree of marginal pairwise correlations between the markers that was used to generate \code{data}. Options are "Low", "Mod" and "High".
#' @details The function is used to perform what is referred to as the "True" analysis in Moreno-Betancur et al. (2017) which is based on perfect data,
#' i.e. the true values of the markers at each of the event times as drawn from the simulation model. This provides a benchmark for analyses performed
#' with error-polluted and incomplete data using \code{\link[survtd]{survtd}}.
#'
#'@return Returns regression coefficient estimates for each covariate based on the "True" analysis, along with 95%
#'   confidence intervals and p-values.
#'
#'@references
#'Moreno-Betancur M, Carlin JB, Brilleman SL, Tanamas S, Peeters A, Wolfe R (2017). Survival analysis
#'with time-dependent covariates subject to missing data or measurement error: Multiple Imputation for Joint Modeling (MIJM).
#'\emph{Biostatistics} [Epub ahead of print 12 Oct 2017].
#'
#'@examples
#'
#'   dat<-simjm(n=200,surv_model="Cox",marker_model="PN",
#'              MErr="High",Miss="None",effects="Weak",corr="Low")
#'
#'   simjm_benchmark(dat,surv_model="Cox",marker_model="PN",corr="Low")
#'
#' @import lme4 survival timereg mice
#' @importFrom stringr str_replace
#' @importFrom ipw tstartfun
#' @importFrom stats as.formula model.extract pnorm pt qt quantile rbinom rexp rnorm runif terms uniroot

simjm_benchmark<-function(data,surv_model="Cox",marker_model="RE",corr="Low")
{
  ##################################### Preliminaries and checks #####################################
  call <- match.call()
  m <- match.call(expand.dots = F)

  if(!surv_model%in%c("Cox","Add"))stop("surv_model must be \"Cox\" or \"Add\"")
  if(!marker_model%in%c("RE","PN"))stop("marker_model must be \"RE\" or \"PN\"")

  formula<-Surv(time=tt,event=event)~Z1+Z2+td(Yij_1)+td(Yij_2)+td(Yij_3)
  id<-"ID"
  visit.time<-"tj"

  special<-c("td")
  Terms<-terms(formula, special, data = data)
  m$formula <- Terms
  m[[1]] <- as.name("model.frame")
  m$id <- m$visit.time <- m$surv_model<-m$marker_model<-m$corr<- NULL
  m$na.action<-NULL
  m <- eval(m, parent.frame())
  mt <- attr(m, "terms")
  intercept <- attr(mt, "intercept")
  S <- model.extract(m, "response")
  if (!inherits(S, "Surv"))
    stop("Response must be a survival object")


  # Recover names of all variables in model
  tname<-as.character(Terms[[2]][2])
  ename<-as.character(Terms[[2]][3])
  fnames<-attr(Terms,"term.labels")[-(attr(Terms,"specials")$td-1)]
  tdnames<-attr(Terms,"term.labels")[(attr(Terms,"specials")$td-1)]
  tdnames<-str_replace(tdnames,"td\\(","")
  tdnames<-str_replace(tdnames,"\\)","")

  if(any(apply(data,2,class)[names(data)%in%tdnames]!="numeric")) stop("Time-depenent variables must be of class \"numeric\"")

  ##################################### Data preparation ##############################################


  # Recover dataset with one row per individual and time-fixed variables to get NA cumulative hazard
  # estimator and interactions with time-fixed covariates
  datU<-unique(cbind(data[,c(id,tname,ename,fnames,"fixed_1","tim_1","fixed_2","tim_2","fixed_3","tim_3")]))
  cumhz<-basehaz(coxph(Surv(datU[,tname],datU[,ename])~1))
  time<-datU[,tname]
  cumhz<-merge(as.data.frame(time),cumhz,by=c("time"),all.x = TRUE,sort=F,suffixes=c("","y"))[,"hazard"]
  datU$cumhz<-cumhz

    # Add these variables to original dataset
  for(Z in fnames)
    datU[,paste("int",Z,sep="")]<-datU[,Z]*datU$cumhz
  data<-merge(data,datU[,c(id,"cumhz",paste("int",fnames,sep=""))],by=id, all.x = TRUE,suffixes=c("x",""))
  data<-do.call("rbind", by(data,data[,id],evMI,visit.time,ename,simplify=F))

  # Base dataset for time-to-event analyses (datSurv): one row per individual per observed event-time
  times <- sort(unique(c(datU[,tname][datU[,ename]!=0])))
  ID<-rep(datU[,id], each = length(times))
  tt<- rep(datU[,tname], each = length(times))
  fuptime <- rep(times, nrow(datU))
  datSurv <- data.frame(
    ID,
    tt,
    fuptime)

  datSurv<-datSurv[datSurv$fuptime<=datSurv$tt,]
  datSurv$tstart<-tstartfun(ID, fuptime, datSurv)
  names(datSurv)[1]<-id
  datSurv$tstart[datSurv$tstart==-1]<-0
  datSurv <- merge(datSurv, datU[,!names(datU)%in%c(tname)],by = id, all.x = TRUE)
  datSurv$event2<-with(datSurv,ifelse(fuptime!=tt,0,get(ename)))
  vtimes<-sort(unique(data[,visit.time]))
  jj<-findInterval(datSurv$fuptime,vtimes)

  datSurv[, visit.time] <- vtimes[jj]

  if(marker_model=="RE")
  {
    datSurv$Yij_1<-datSurv$fixed_1+datSurv$tim_1*datSurv$fuptime
    datSurv$Yij_2<-datSurv$fixed_2+datSurv$tim_2*datSurv$fuptime
    datSurv$Yij_3<-datSurv$fixed_3+datSurv$tim_3*datSurv$fuptime
  }else
  {
    alphaY2Y1<-alphaY3Y1<-ifelse(corr=="Low",0,ifelse(corr=="Mod",0.1,0.5))
    alphaY3Y2<-ifelse(corr=="Low",0,ifelse(corr=="Mod",0.05,0.05))
    datSurv$Yij_1<-datSurv$fixed_1+datSurv$tim_1*datSurv$fuptime
    datSurv$Yij_2<-datSurv$fixed_2+datSurv$tim_2*datSurv$fuptime+alphaY2Y1*datSurv$Yij_1
    datSurv$Yij_3<-datSurv$fixed_3+datSurv$tim_3*datSurv$fuptime+alphaY3Y1*datSurv$Yij_1+alphaY3Y2*datSurv$Yij_2}
 ######################################## ANALYSIS ######################################################

    if(surv_model=="Cox")
    {
      fit<-coxph(as.formula(paste("Surv(time=tstart,time2=fuptime,event=event2)~",paste(c(tdnames,fnames),collapse="+"))),datSurv)
      res<-summ.cox(fit)
    }else
    {
      fit<-aalen(as.formula(paste("Surv(time=tstart,time2=fuptime,event=event2)~",paste(paste("const(",c(tdnames,fnames),")",sep=""),
                                                                                        collapse="+"))),
                 data=datSurv,robust=F,n.sim=0)
      res<-summ.aalen(fit)
    }


  return(list(Call=call,Results=res))


}
